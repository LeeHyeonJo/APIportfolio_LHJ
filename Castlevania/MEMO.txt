0629 키보드 입력 추가 : (inputclass)
- input class.h
겟키, 겟키다운, 켓키업 (클래스 안에 모아두고 쓸거임 )
enum 문법, 키코드 키스테이터스의 기능, 

- input class.cpp
update() 함수 내부 직접 채워보기 

공부 방법: 전체 흐름만 파악하고 나중에 다시와서 다시 파악하기 


0630 Time class 구현 
- 델타 타임의 개념 이해 (걸리는 시간) : 현재 시간 - 이전 시간 
- 프레임의 개념 이해 : 1초당 프로그램이 도는데 걸리는 시간 
ㄴ 30 프레임 : 1초당 30번 돈다는 뜻. 델타 타임을 구해서 역수를 취하면 프레임이 나온다

숙제 힌트: vector mkey를 배열로 만든다. 
1) 원을 배열로 만들기 (벡터 / 동적 할당한 배열. 푸쉬 백 될때 공간이 유동적으로 할당됨)
2) 윈도우 창 크기는 타이틀 바 까지 포함한 크기. 타이틀 바를 제외하고 윈도우 크기를 구하는 함수를 새로 써야 함. 
>> 렌더 파트가 좀 더 까다로움. 900 * 500 

0704 
1. 잔상을 지운다. 
= 윈이 이동한 후, 그 위에 네모를
크게 덧씌워준다. 
 - 렌더에서 직사각형을 그리는 함수를
호출해서 씌워줄거임. 
// UINT 자료형은 무얼 의미하는가? 
(insigned int. 양의 정수) 
-콘솔 헤더에서 변수 선언(생성&초기화 잊지 말기) 후
cpp 의 렌더함수에서 구현. 

//기본으로 생성되는 윈도우의 크기는 1600*900

문제 >> 깜빡임이 발생 

2. 이 화면의 깜빡임을 없애줄거임
 >> 사용할 알고리즘은 [더블 버퍼링] 
화면 2개를 띄우고, 각자에 따로 그림을 그리며
시선을 계속 바꾸는 것. 

이걸 winapi에서 완벽히 구현하기는 어려움.
이 원리를 유사하게 구현해볼 것. 
(*winapi에선 시야 바꾸기가 안되는듯) 

a. 두번째 화면을 만들기 (이니셜라이즈) 
b. 두번째 화면에 그림을 갱신 (업데이트를 진행하면 알아서 진행됨~아마도?) 
c. 갱신된 두번째 화면을 첫번째 화면 (시야가 고정된 곳)에 복사 (렌더 - 비트비트함수) 
b - c를 무한히 반복 

>> 그 전에, 클라이언트 영역을 원하는 크기로 확실하게 지정해서 띄워주고자 함. 
:: 이 과정이 콘솔 cpp에서 rect~showindow까지. (첫 화면의 크기를 구함, 그리고 그걸 두번째 화면 생성에도 쓰는 것) 

a. 그 후! 내가 재생성한 윈도우의 해상도와 동일한 화면을 만든다. 
-> 변수 선언 먼저. 
a-1) HBITMAP 도화지 생성. 비트맵은 24비트의  RGB값을 가진다. 
a-2) ㄴ 이 도화지에서 사용할 새로운 핸들 HDC ~ 을 생성. 이는 윈도우 api 권장사항이다. 
** 이 변수들도 생성/초기화 잊지 말것. 기본**

a-3) 도화지에 함수 CreateCompatibleBitmap로 화면을 생성해준다. 
a-4) 도화지(엠버퍼)가 사용할 DC를 함수 CreateCompatibleDC로 새롭게 만들어준다. 

a-5) 새롭게 생성된 도화지와 새롭게 생성된 DC를 연결해준다!! 
** 비트맵은 생성될 때, 항상 디폴트 DC를 갖고 있기 때문** 
(HBITMAP)SelectObject(mBackHdc, mBackBuffer); <- 이 함수는 두개를 연결해주는 동시에, 
해당 비트맵이 갖고 있던 디폴트 DC를 반환한다. (이건 동적할당된 메모리이기 때문에 지워주어야 함) 

a-6) 반환된 디폴트 DC를 메모리 해제


b-1) 두번째 도화지(엠버퍼)를 첫 도화지에 복사
: BitBlt(앞도화지,뒷도화지)로 복사해준다. 

b-2) 두번째 도화지에 모든 그림이 그려지고, 첫 도화지는 복사만 되므로(비트비트) 
렌더의 그려주는 과정에서 사용할 DC는 첫 도화지(mhdc) 가 아니라, 백버퍼의dc로 바뀌어야 한다. 

0705: 씬(장면) 띄우기 
유니티 - 씬 / 언리얼 - 레벨 

게임은 다양한 장면(씬,레벨)으로 이루어진다. 