// 가상함수와 상속 //

(여기 0706 앞에 설명 중)

* 상속을 받으면 자식의 값은 부모의 자료형을 취한 변수에 저장할 수 있따. 

* 형변환을 해서 엄마의 거에 저장을 해서, 그 안의 함수에 접근하려고 하면
* 엄마 클래스의 함수로 접근하게 된다. (이게 문제) => 해결하기 위한 수단이 버추얼. 

// 자식 클래스가 부모 클래스를 상속 받으면, 자식 클래스의 객체가 생성될땐 부모의 클래스의 크기만큼이 + 됨. 

// B와 C를 전부 부모인 A에 저장해둔 뒤
// for문을 돌면서 A를 돌면 A함수가 호출됨. 

// ㄴ 각각 자식 함수에 들어가고 싶음. 
// ㄴ 그래서 A 엄마 함수에 버추얼 걸고, 자식에겐 버추얼과 오버라이드를 걸어준다. 


 ** 직계만 가능한게 아님 ** 
 0706:: 
 필터 : 콘첸트 > 씬 & 게임오브젝트(플레이어)
 // ㄴ 캐릭터를 만들때마다 플레이어 클래스가 추가된다. 

 // 플레이어는 게임 오브젝트를 상속받는다. 

 // ㄴ 버추얼은 기본적으로 부모쪽에 몰림. 
 // ㄴ 그러나 안전을 위해서 만들때마다 다 걸어두는것이 좋다. 


 // ??(인풋에 있던게) 가 플레이어 업데이트 함수로 이동 
 // ㄴ 업데이트 하기 위해선 위치를 알아야 하므로 부모에 접속해서 받아옴.
 

 //> 타이틀씬, 플레이어

 .. >> 유니티 방식으로 무언가를 구현. 헤더 하나만
 // 오브젝트 헤더. <- 여기에 게임 오브젝트 들어가고 , 씬도 들어갈것. 

 // 씬을 여러개 만들 것이므로 씬을 관리하는 클래스를 따로 둘것 
 :: 씬 매니저 - 타이틀 씬에서 클릭 시 다음 씬으로 넘어가는걸 관리 

 :: 씬이라는 배열을 갖고 있어야 함. 
 ㄴㄴ 어디서든 사용가능해야함. <- 전역으로 선언해야함. 




 // 잊기 쉬운 포인트 //
 * private 변수는 그대로 꺼내쓸 수 없으므로, 반드시 함수를 사용해서 꺼내줘야 한다.
 * set, get 함수가 그 역할 (private 변수에 값 지정 & 그 값을 꺼내쓰는 함수)

 * 동적 할당(new)를 했을 때: 호출되는건 무조건 그 자료형의 생성자이다. 
 ex) new Transform(); // 이런게 있다면, 반드시 Transform()의 생성자부터 체크해야 한다. 

 * 생성자의 호출순서는 부모 - 자식 순. (부모의 생성자에 딱히 뭔가 없다면 자식으로 넘어감)
 * 소멸자의 호출순서는 자식 - 부모 순. 이때 부모의 소멸자에 virtual(가상화)을 걸어주지 않으면 
 --(자식인가 부모인가)가 두번 연속해서 지워지게 되므로 오류가 난다. 


 // 0705 필기 진행과정 // 
 ** 드디어 이해함 (트랜스,렌더러 동적할당 시 - 호출된 생성자를 보면 eComponent로 이름을 지어주고 있음)
 ** 그래서 트랜스/랜더러를 우리가 구분할 수 있게 되는 것임. 

ㄴ 일단 무조건 받아쓰기 한번. 그리고 통 구현 3~5번 반복하면서 이해하기. 